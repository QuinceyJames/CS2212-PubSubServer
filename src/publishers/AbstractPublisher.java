package publishers;

import baseEntities.IEntity;
import events.AbstractEvent;
import strategies.publisher.AbstractStrategy;
import strategies.publisher.StrategyFactory;
import strategies.publisher.StrategyName;

/**
 * 
 * Package-Protected class that implements the "State Design Pattern". It forces
 * all implementing classes to define an interchangeable state that is
 * encapsulated in the concrete classes. This allows for easy incorporation of
 * various states that can define unique logic. These classes should not be used
 * outside of this package.
 * 
 * @author rblack43
 *
 */
public abstract class AbstractPublisher implements IEntity, Comparable<AbstractPublisher> {

	
	/**
	 * Variable encapsulating the {@link strategies.publisher.AbstractStrategy AbstractStrategy} associated
	 * with an {@link AbstractPublisher}
	 */
	protected AbstractStrategy publishingStrategy;
	
	
	/**
	 * Variable encapsulating the ID number associated with an
	 * {@link AbstractPublisher}
	 */
	protected int publisherID;

	
	/**
	 * Constructor for an {@link AbstractPublisher} that sets the {@link #publishingStrategy}
	 * and {@link #publisherID} for said Publisher.
	 * 
	 * All concrete publisher instances utilize this method.
	 * 
	 * @param strategyName is the {@link strategies.publisher.StrategyName StrategyName} of the {@link publishingStrategy}
	 * to be associated with the given {@link AbstractPublisher}.
	 * @param publisherID is the {@link #publisherID} to be associated with the given {@link AbstractPublisher}.
	 */
	protected AbstractPublisher(StrategyName strategyName, int publisherID) {
		this.publishingStrategy = StrategyFactory.createStrategy(strategyName); //setting strategy
		this.publisherID = publisherID; //setting ID
		System.out.println(String.format("%s has been created", this)); //printing required output as per document using defined toString method in AbstractPublisher
}

	@Override
	public String toString() {
		return String.format("%s #%d", getClass().getSimpleName(), publisherID); //creates string in the form "AlphaPublisher #1"
	} 

	
	/**
	 * Sets the {@link strategies.publisher.AbstractStrategy AbstractStrategy} for this {@link AbstractPublisher} implementation using the {@link StrategyFactory}
	 * 
	 * @param strategyName the entry from the {@link StrategyName} enumeration that we
	 *                  want the new AbstractStrategy of the AbstractPublisher to be
	 */
	public void setStrategy(AbstractStrategy publishingStrategy) {
			this.publishingStrategy = publishingStrategy;
			System.out.println(String.format("%s has %s", this, publishingStrategy)); //printing required output as per document using defined toString methods in AbstractPublisher and AbstractStrategy
	}

	
	/**
	 * Method to publish a default event via the {@link #publishingStrategy} that is also generated by this strategy, in the case that an event was not specified
	 */
	public void publish() {
		publishingStrategy.doPublish(this);
	}

	
	/**
	 * Method to publish event specified as per the parameter via the {@link #publishingStrategy} in the case that an event was specified
	 *
	 * @param event event specified to be published
	 */
	public void publish(AbstractEvent event) {
		publishingStrategy.doPublish(event, this);
	}

	@Override
	public int compareTo(AbstractPublisher o) { //Since a map was used to store Publishers, this method is implemented to help store in order 
		return o.publisherID - publisherID; //ordered by publisherID, from least to greatest 
	}
}
